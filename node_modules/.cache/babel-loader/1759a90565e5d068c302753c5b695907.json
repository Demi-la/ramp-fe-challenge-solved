{"ast":null,"code":"// import { useCallback, useState } from \"react\"\n// import { PaginatedRequestParams, PaginatedResponse, Transaction } from \"../utils/types\"\n// import { PaginatedTransactionsResult } from \"./types\"\n// import { useCustomFetch } from \"./useCustomFetch\"\n// export function usePaginatedTransactions(): PaginatedTransactionsResult {\n//   const { fetchWithCache, loading } = useCustomFetch()\n//   const [paginatedTransactions, setPaginatedTransactions] = useState<PaginatedResponse<\n//     Transaction[]\n//   > | null>(null)\n//   const fetchAll = useCallback(async () => {\n//     const response = await fetchWithCache<PaginatedResponse<Transaction[]>, PaginatedRequestParams>(\n//       \"paginatedTransactions\",\n//       {\n//         page: paginatedTransactions === null ? 0 : paginatedTransactions.nextPage,\n//       }\n//     )\n//     setPaginatedTransactions((previousResponse) => {\n//       if (response === null || previousResponse === null) {\n//         return response\n//       }\n//       const previousData = response.data\n//       const currentData = previousResponse.data\n//       const combinedArray = [...currentData, ...previousData]\n//       console.log({ data: combinedArray, nextPage: response.nextPage })\n//       return { data: combinedArray, nextPage: response.nextPage }\n//     })\n//   }, [fetchWithCache, paginatedTransactions])\n//   const invalidateData = useCallback(() => {\n//     setPaginatedTransactions(null)\n//   }, [])\n//   return { data: paginatedTransactions, loading, fetchAll, invalidateData }\n// }","map":{"version":3,"names":[],"sources":["C:/Users/User/Desktop/ramp-fe-challenge/src/hooks/usePaginatedTransactions.ts"],"sourcesContent":["// import { useCallback, useState } from \"react\"\n// import { PaginatedRequestParams, PaginatedResponse, Transaction } from \"../utils/types\"\n// import { PaginatedTransactionsResult } from \"./types\"\n// import { useCustomFetch } from \"./useCustomFetch\"\n\n// export function usePaginatedTransactions(): PaginatedTransactionsResult {\n//   const { fetchWithCache, loading } = useCustomFetch()\n//   const [paginatedTransactions, setPaginatedTransactions] = useState<PaginatedResponse<\n//     Transaction[]\n//   > | null>(null)\n\n\n\n//   const fetchAll = useCallback(async () => {\n//     const response = await fetchWithCache<PaginatedResponse<Transaction[]>, PaginatedRequestParams>(\n//       \"paginatedTransactions\",\n//       {\n//         page: paginatedTransactions === null ? 0 : paginatedTransactions.nextPage,\n//       }\n//     )\n\n  \n\n//     setPaginatedTransactions((previousResponse) => {\n//       if (response === null || previousResponse === null) {\n//         return response\n//       }\n//       const previousData = response.data\n//       const currentData = previousResponse.data\n\n//       const combinedArray = [...currentData, ...previousData]\n//       console.log({ data: combinedArray, nextPage: response.nextPage })\n\n//       return { data: combinedArray, nextPage: response.nextPage }\n//     })\n//   }, [fetchWithCache, paginatedTransactions])\n\n//   const invalidateData = useCallback(() => {\n//     setPaginatedTransactions(null)\n//   }, [])\n\n//   return { data: paginatedTransactions, loading, fetchAll, invalidateData }\n// }\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA"},"metadata":{},"sourceType":"module"}