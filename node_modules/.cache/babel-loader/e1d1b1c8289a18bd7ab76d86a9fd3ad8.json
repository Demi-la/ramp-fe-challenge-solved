{"ast":null,"code":"import mockData from \"../mock-data.json\";\nconst TRANSACTIONS_PER_PAGE = 5;\nconst data = {\n  employees: mockData.employees,\n  transactions: mockData.transactions,\n  employee: mockData.employees\n};\nexport const getEmployees = () => data.employees;\nexport const getTransactionsPaginated = _ref => {\n  let {\n    page\n  } = _ref;\n\n  if (page === null) {\n    throw new Error(\"Page cannot be null\");\n  }\n\n  const start = page * TRANSACTIONS_PER_PAGE;\n  const end = start + TRANSACTIONS_PER_PAGE;\n\n  if (start > data.transactions.length) {\n    throw new Error(`Invalid page ${page}`);\n  }\n\n  const nextPage = end < data.transactions.length ? page + 1 : null;\n  return {\n    nextPage,\n    data: data.transactions.slice(start, end)\n  };\n};\nexport const getTransactionsByEmployee = _ref2 => {\n  let {\n    id,\n    amount,\n    employee,\n    merchant,\n    date,\n    approved: boolean\n  } = _ref2;\n\n  if (!employeeId) {\n    throw new Error(\"Employee id cannot be empty\");\n  }\n\n  return data.transactions.filter(transaction => transaction.employee.id === employeeId);\n}; // export const getTransactionsByEmployee = ({ employeeId }: RequestByEmployeeParams) => {\n//   if (!employeeId || employeeId.length === 0) {\n//     throw new Error(\"Employee ids cannot be empty\");\n//   } \n//   else if (employeeId.includes(\"all\")) {\n//     return data.transactions; // Return all transactions if \"all\" is selected\n//   }\n//   return data.transactions.filter((transaction) => employeeId.includes(transaction.employee.id));\n// };\n\nexport const setTransactionApproval = _ref3 => {\n  let {\n    transactionId,\n    value\n  } = _ref3;\n  const transaction = data.transactions.find(currentTransaction => currentTransaction.id === transactionId);\n\n  if (!transaction) {\n    throw new Error(\"Invalid transaction to approve\");\n  }\n\n  transaction.approved = value;\n};","map":{"version":3,"names":["mockData","TRANSACTIONS_PER_PAGE","data","employees","transactions","employee","getEmployees","getTransactionsPaginated","page","Error","start","end","length","nextPage","slice","getTransactionsByEmployee","id","amount","merchant","date","approved","boolean","employeeId","filter","transaction","setTransactionApproval","transactionId","value","find","currentTransaction"],"sources":["C:/Users/User/Desktop/ramp-fe-challenge/src/utils/requests.ts"],"sourcesContent":["import {\n  PaginatedRequestParams,\n  PaginatedResponse,\n  RequestByEmployeeParams,\n  SetTransactionApprovalParams,\n  Transaction,\n  Employee,\n} from \"./types\"\nimport mockData from \"../mock-data.json\"\n\nconst TRANSACTIONS_PER_PAGE = 5\n\nconst data: { employees: Employee[]; transactions: Transaction[]; employee: Employee[]  } = {\n  employees: mockData.employees,\n  transactions: mockData.transactions,\n  employee: mockData.employees,\n}\n\nexport const getEmployees = (): Employee[] => data.employees\n\nexport const getTransactionsPaginated = ({\n  page,\n}: PaginatedRequestParams): PaginatedResponse<Transaction[]> => {\n  if (page === null) {\n    throw new Error(\"Page cannot be null\")\n  }\n\n  const start = page * TRANSACTIONS_PER_PAGE\n  const end = start + TRANSACTIONS_PER_PAGE\n\n  if (start > data.transactions.length) {\n    throw new Error(`Invalid page ${page}`)\n  }\n\n  const nextPage = end < data.transactions.length ? page + 1 : null\n\n  return {\n    nextPage,\n    data: data.transactions.slice(start, end),\n  }\n}\n\nexport const getTransactionsByEmployee = ({ id, amount, employee, merchant, date, approved: boolean}: Transaction) => {\n  if (!employeeId) {\n    throw new Error(\"Employee id cannot be empty\")\n  }\n  \n\n  return data.transactions.filter((transaction) => transaction.employee.id === employeeId)\n}\n\n// export const getTransactionsByEmployee = ({ employeeId }: RequestByEmployeeParams) => {\n//   if (!employeeId || employeeId.length === 0) {\n//     throw new Error(\"Employee ids cannot be empty\");\n//   } \n\n//   else if (employeeId.includes(\"all\")) {\n//     return data.transactions; // Return all transactions if \"all\" is selected\n//   }\n\n//   return data.transactions.filter((transaction) => employeeId.includes(transaction.employee.id));\n// };\n\nexport const setTransactionApproval = ({ transactionId, value }: SetTransactionApprovalParams): void => {\n  const transaction = data.transactions.find(\n    (currentTransaction) => currentTransaction.id === transactionId\n  )\n\n  if (!transaction) {\n    throw new Error(\"Invalid transaction to approve\")\n  }\n\n  transaction.approved = value\n}\n"],"mappings":"AAQA,OAAOA,QAAP,MAAqB,mBAArB;AAEA,MAAMC,qBAAqB,GAAG,CAA9B;AAEA,MAAMC,IAAmF,GAAG;EAC1FC,SAAS,EAAEH,QAAQ,CAACG,SADsE;EAE1FC,YAAY,EAAEJ,QAAQ,CAACI,YAFmE;EAG1FC,QAAQ,EAAEL,QAAQ,CAACG;AAHuE,CAA5F;AAMA,OAAO,MAAMG,YAAY,GAAG,MAAkBJ,IAAI,CAACC,SAA5C;AAEP,OAAO,MAAMI,wBAAwB,GAAG,QAEwB;EAAA,IAFvB;IACvCC;EADuC,CAEuB;;EAC9D,IAAIA,IAAI,KAAK,IAAb,EAAmB;IACjB,MAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;EACD;;EAED,MAAMC,KAAK,GAAGF,IAAI,GAAGP,qBAArB;EACA,MAAMU,GAAG,GAAGD,KAAK,GAAGT,qBAApB;;EAEA,IAAIS,KAAK,GAAGR,IAAI,CAACE,YAAL,CAAkBQ,MAA9B,EAAsC;IACpC,MAAM,IAAIH,KAAJ,CAAW,gBAAeD,IAAK,EAA/B,CAAN;EACD;;EAED,MAAMK,QAAQ,GAAGF,GAAG,GAAGT,IAAI,CAACE,YAAL,CAAkBQ,MAAxB,GAAiCJ,IAAI,GAAG,CAAxC,GAA4C,IAA7D;EAEA,OAAO;IACLK,QADK;IAELX,IAAI,EAAEA,IAAI,CAACE,YAAL,CAAkBU,KAAlB,CAAwBJ,KAAxB,EAA+BC,GAA/B;EAFD,CAAP;AAID,CApBM;AAsBP,OAAO,MAAMI,yBAAyB,GAAG,SAA6E;EAAA,IAA5E;IAAEC,EAAF;IAAMC,MAAN;IAAcZ,QAAd;IAAwBa,QAAxB;IAAkCC,IAAlC;IAAwCC,QAAQ,EAAEC;EAAlD,CAA4E;;EACpH,IAAI,CAACC,UAAL,EAAiB;IACf,MAAM,IAAIb,KAAJ,CAAU,6BAAV,CAAN;EACD;;EAGD,OAAOP,IAAI,CAACE,YAAL,CAAkBmB,MAAlB,CAA0BC,WAAD,IAAiBA,WAAW,CAACnB,QAAZ,CAAqBW,EAArB,KAA4BM,UAAtE,CAAP;AACD,CAPM,C,CASP;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA,OAAO,MAAMG,sBAAsB,GAAG,SAAkE;EAAA,IAAjE;IAAEC,aAAF;IAAiBC;EAAjB,CAAiE;EACtG,MAAMH,WAAW,GAAGtB,IAAI,CAACE,YAAL,CAAkBwB,IAAlB,CACjBC,kBAAD,IAAwBA,kBAAkB,CAACb,EAAnB,KAA0BU,aADhC,CAApB;;EAIA,IAAI,CAACF,WAAL,EAAkB;IAChB,MAAM,IAAIf,KAAJ,CAAU,gCAAV,CAAN;EACD;;EAEDe,WAAW,CAACJ,QAAZ,GAAuBO,KAAvB;AACD,CAVM"},"metadata":{},"sourceType":"module"}